"""
Enhanced Vulnerability Scanner v2.0

Comprehensive vulnerability detection with:
- Manifest analysis (exported components)
- Pattern matching in decompiled code
- OWASP MSTG 2024 mapping
- Evidence extraction with source code paths
- Severity scoring

Reference: MobSF, OWASP Top 10 Mobile 2024, MSTG
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Tuple
from enum import Enum
import logging
import re
from pathlib import Path

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Info"


class VulnerabilityCategory(Enum):
    """OWASP MSTG 2024 Categories"""
    # Storage & Privacy
    DATA_STORAGE = "Data Storage"
    
    # Communication
    NETWORK_SECURITY = "Network Security"
    
    # Cryptography
    CRYPTOGRAPHY = "Cryptography"
    
    # Components
    COMPONENT_SECURITY = "Component Security"
    
    # Code Quality
    CODE_QUALITY = "Code Quality"
    HARDCODED_SECRETS = "Hardcoded Secrets"
    
    # Injection
    INJECTION = "Injection"
    
    # Android-Specific
    ANDROID_SPECIFIC = "Android-Specific"
    REVERSE_ENGINEERING = "Reverse Engineering"
    
    # Permissions
    PERMISSIONS = "Permissions"


@dataclass
class VulnerabilityPattern:
    """Pattern definition for vulnerability detection"""
    id: str
    name: str
    category: VulnerabilityCategory
    severity: VulnerabilitySeverity
    description: str
    owasp_mstg: str  # e.g., "MSTG-STORAGE-1"
    cwe: str  # e.g., "CWE-312"
    
    # Pattern matchers
    api_patterns: List[str] = field(default_factory=list)
    string_patterns: List[str] = field(default_factory=list)
    regex_patterns: List[str] = field(default_factory=list)  # Compiled regexes
    method_patterns: List[str] = field(default_factory=list)
    
    remediation: str = ""
    references: List[str] = field(default_factory=list)


@dataclass
class Vulnerability:
    """Detected vulnerability in app"""
    vulnerability_id: str
    name: str
    category: str
    severity: str
    location: Dict  # {file, class, method, line}
    evidence: List[str]  # Code snippets
    description: str = ""
    remediation: str = ""
    cwe: str = ""
    owasp_mstg: str = ""
    source_code: str = ""  # Full source code context
    line_numbers: List[int] = field(default_factory=list)
    
    def to_dict(self):
        return {
            "id": self.vulnerability_id,
            "name": self.name,
            "category": self.category,
            "severity": self.severity,
            "location": self.location,
            "evidence": self.evidence,
            "description": self.description,
            "remediation": self.remediation,
            "cwe": self.cwe,
            "owasp_mstg": self.owasp_mstg,
            "source_code": self.source_code,
            "line_numbers": self.line_numbers,
        }


class OWASPMSTGMapper:
    """Map vulnerabilities to OWASP MSTG 2024"""
    
    @staticmethod
    def map_to_top10() -> Dict[str, str]:
        """Map patterns to OWASP MSTG 2024 Top 10"""
        return {
            "COMP_EXPORTED_ACTIVITY": "MSTG-ANDROID-1",
            "COMP_EXPORTED_SERVICE": "MSTG-ANDROID-1",
            "COMP_EXPORTED_BROADCAST": "MSTG-ANDROID-1",
            "COMP_EXPORTED_CONTENT": "MSTG-ANDROID-1",
            "CRYPTO_WEAK_ALGORITHM": "MSTG-CRYPTO-2",
            "CRYPTO_HARDCODED_KEY": "MSTG-CRYPTO-1",
            "STORAGE_PLAINTEXT": "MSTG-STORAGE-1",
            "STORAGE_EXTERNAL": "MSTG-STORAGE-2",
            "NET_UNENCRYPTED_HTTP": "MSTG-NETWORK-1",
            "NET_NO_CERT_PINNING": "MSTG-NETWORK-3",
            "CODE_DEBUG_LOGS": "MSTG-STORAGE-3",
            "CODE_HARDCODED_SECRET": "MSTG-STORAGE-4",
            "INJECTION_SQL": "MSTG-CODE-4",
            "INJECTION_COMMAND": "MSTG-CODE-4",
            "ANDROID_WEAK_RANDOM": "MSTG-CRYPTO-4",
            "ANDROID_INSECURE_DESER": "MSTG-ANDROID-8",
        }


class VulnerabilityPatternsV2:
    """Enhanced vulnerability pattern registry"""
    
    @staticmethod
    def get_all_patterns() -> Dict[str, VulnerabilityPattern]:
        """Return all enhanced vulnerability patterns"""
        
        patterns = {
            # ==================== COMPONENT SECURITY ====================
            # CRITICAL: Exported components
            "COMP_EXPORTED_ACTIVITY": VulnerabilityPattern(
                id="COMP_EXPORTED_ACTIVITY",
                name="Exported Activity",
                category=VulnerabilityCategory.COMPONENT_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="Activity is exported without proper protection, allowing other apps to launch it",
                owasp_mstg="MSTG-ANDROID-1",
                cwe="CWE-927",
                string_patterns=['<activity', 'exported="true"'],
                remediation="Set exported=false or add proper permission/signature checks",
                references=["OWASP-M1", "CWE-927"]
            ),
            
            "COMP_EXPORTED_SERVICE": VulnerabilityPattern(
                id="COMP_EXPORTED_SERVICE",
                name="Exported Service",
                category=VulnerabilityCategory.COMPONENT_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="Service is exported without protection, allowing unauthorized access",
                owasp_mstg="MSTG-ANDROID-1",
                cwe="CWE-927",
                string_patterns=['<service', 'exported="true"'],
                remediation="Set exported=false or add permission checks",
            ),
            
            "COMP_EXPORTED_BROADCAST": VulnerabilityPattern(
                id="COMP_EXPORTED_BROADCAST",
                name="Exported Broadcast Receiver",
                category=VulnerabilityCategory.COMPONENT_SECURITY,
                severity=VulnerabilitySeverity.MEDIUM,
                description="Broadcast receiver is exported, allowing any app to send broadcasts",
                owasp_mstg="MSTG-ANDROID-1",
                cwe="CWE-927",
                string_patterns=['<receiver', 'exported="true"'],
                remediation="Set exported=false or add permission filtering",
            ),
            
            "COMP_EXPORTED_CONTENT": VulnerabilityPattern(
                id="COMP_EXPORTED_CONTENT",
                name="Exported Content Provider",
                category=VulnerabilityCategory.COMPONENT_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="Content Provider is exported without proper permission, exposing data",
                owasp_mstg="MSTG-ANDROID-1",
                cwe="CWE-927",
                string_patterns=['<provider', 'exported="true"'],
                remediation="Use proper URI permission checking or disable export",
            ),
            
            # ==================== HARDCODED SECRETS ====================
            "HARDCODED_API_KEY": VulnerabilityPattern(
                id="HARDCODED_API_KEY",
                name="Hardcoded API Key",
                category=VulnerabilityCategory.HARDCODED_SECRETS,
                severity=VulnerabilitySeverity.CRITICAL,
                description="API key or authentication token hardcoded in source code",
                owasp_mstg="MSTG-STORAGE-4",
                cwe="CWE-798",
                regex_patterns=[
                    r'(?i)(api[_-]?key|apikey|api[_-]?secret)["\s]*[=:]["\s]*[a-zA-Z0-9]{20,}',
                    r'(?i)aws[_-]?(access|secret)["\s]*[=:]["\s]*[a-zA-Z0-9]{20,}',
                    r'(?i)bearer["\s]+[a-zA-Z0-9\-._~+/]+={0,2}',
                ],
                remediation="Move secrets to secure configuration or key management system",
                references=["OWASP-M2", "CWE-798"]
            ),
            
            "HARDCODED_PASSWORD": VulnerabilityPattern(
                id="HARDCODED_PASSWORD",
                name="Hardcoded Password/Credential",
                category=VulnerabilityCategory.HARDCODED_SECRETS,
                severity=VulnerabilitySeverity.CRITICAL,
                description="Password or credential hardcoded in source code",
                owasp_mstg="MSTG-STORAGE-4",
                cwe="CWE-798",
                string_patterns=["password", "passwd", "pwd", "secret", "credential"],
                regex_patterns=[
                    r'(?i)(password|passwd|pwd)["\s]*[=:]["\s]*["\']([^"\']{4,})["\']',
                    r'(?i)(username|user)["\s]*[=:]["\s]*["\']([^"\']+)["\'].*password["\s]*[=:]["\s]*["\']',
                ],
                remediation="Store credentials securely using Android Keystore or similar",
                references=["OWASP-M2", "CWE-798"]
            ),
            
            # ==================== CRYPTOGRAPHY ====================
            "WEAK_CRYPTO_MD5": VulnerabilityPattern(
                id="WEAK_CRYPTO_MD5",
                name="MD5 Hashing Algorithm",
                category=VulnerabilityCategory.CRYPTOGRAPHY,
                severity=VulnerabilitySeverity.MEDIUM,
                description="MD5 is cryptographically broken and should not be used",
                owasp_mstg="MSTG-CRYPTO-2",
                cwe="CWE-327",
                string_patterns=["MD5", "md5"],
                remediation="Use SHA-256 or stronger algorithms",
            ),
            
            "WEAK_CRYPTO_SHA1": VulnerabilityPattern(
                id="WEAK_CRYPTO_SHA1",
                name="SHA-1 Hashing Algorithm",
                category=VulnerabilityCategory.CRYPTOGRAPHY,
                severity=VulnerabilitySeverity.MEDIUM,
                description="SHA-1 should not be used for security",
                owasp_mstg="MSTG-CRYPTO-2",
                cwe="CWE-327",
                string_patterns=["SHA1", "SHA-1"],
                remediation="Use SHA-256 or stronger algorithms",
            ),
            
            "WEAK_CRYPTO_ECB": VulnerabilityPattern(
                id="WEAK_CRYPTO_ECB",
                name="ECB Mode (Weak)",
                category=VulnerabilityCategory.CRYPTOGRAPHY,
                severity=VulnerabilitySeverity.HIGH,
                description="ECB (Electronic Codebook) mode is cryptographically weak",
                owasp_mstg="MSTG-CRYPTO-2",
                cwe="CWE-327",
                string_patterns=["ECB", "ecb", "Cipher/NONE"],
                regex_patterns=[r'Cipher\.getInstance\(["\'].*ECB'],
                remediation="Use GCM, CBC, or other authenticated modes",
            ),
            
            "WEAK_CRYPTO_RC4": VulnerabilityPattern(
                id="WEAK_CRYPTO_RC4",
                name="RC4 Cipher",
                category=VulnerabilityCategory.CRYPTOGRAPHY,
                severity=VulnerabilitySeverity.HIGH,
                description="RC4 is cryptographically broken",
                owasp_mstg="MSTG-CRYPTO-2",
                cwe="CWE-327",
                string_patterns=["RC4", "rc4"],
                remediation="Use AES or other approved algorithms",
            ),
            
            # ==================== DATA STORAGE ====================
            "SHARED_PREFS_PLAINTEXT": VulnerabilityPattern(
                id="SHARED_PREFS_PLAINTEXT",
                name="Unencrypted SharedPreferences",
                category=VulnerabilityCategory.DATA_STORAGE,
                severity=VulnerabilitySeverity.HIGH,
                description="Sensitive data stored in SharedPreferences without encryption",
                owasp_mstg="MSTG-STORAGE-1",
                cwe="CWE-312",
                string_patterns=["SharedPreferences", "getSharedPreferences"],
                api_patterns=["MODE_PRIVATE"],
                remediation="Use EncryptedSharedPreferences or Android Keystore",
            ),
            
            "EXTERNAL_STORAGE_WRITE": VulnerabilityPattern(
                id="EXTERNAL_STORAGE_WRITE",
                name="Data Written to External Storage",
                category=VulnerabilityCategory.DATA_STORAGE,
                severity=VulnerabilitySeverity.MEDIUM,
                description="App writes data to external storage (world-readable)",
                owasp_mstg="MSTG-STORAGE-2",
                cwe="CWE-377",
                string_patterns=["getExternalFilesDir", "getExternalCacheDir"],
                api_patterns=["Environment.DIRECTORY"],
                remediation="Use internal storage with proper permissions",
            ),
            
            # ==================== NETWORK SECURITY ====================
            "CLEARTEXT_TRAFFIC": VulnerabilityPattern(
                id="CLEARTEXT_TRAFFIC",
                name="Cleartext (HTTP) Traffic",
                category=VulnerabilityCategory.NETWORK_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="App transmits data over unencrypted HTTP",
                owasp_mstg="MSTG-NETWORK-1",
                cwe="CWE-295",
                string_patterns=["http://"],
                api_patterns=["HttpURLConnection"],
                remediation="Use HTTPS/TLS for all network communication",
            ),
            
            "NO_CERT_PINNING": VulnerabilityPattern(
                id="NO_CERT_PINNING",
                name="Missing Certificate Pinning",
                category=VulnerabilityCategory.NETWORK_SECURITY,
                severity=VulnerabilitySeverity.MEDIUM,
                description="No certificate pinning for HTTPS connections",
                owasp_mstg="MSTG-NETWORK-3",
                cwe="CWE-295",
                api_patterns=["HttpsURLConnection", "OkHttp"],
                remediation="Implement certificate or public key pinning",
            ),
            
            # ==================== CODE QUALITY ====================
            "DEBUG_LOGGING": VulnerabilityPattern(
                id="DEBUG_LOGGING",
                name="Debug Logging",
                category=VulnerabilityCategory.CODE_QUALITY,
                severity=VulnerabilitySeverity.MEDIUM,
                description="Debug log statements may expose sensitive information",
                owasp_mstg="MSTG-STORAGE-3",
                cwe="CWE-532",
                api_patterns=["Log.d", "Log.v", "System.out.println"],
                remediation="Remove debug logs or use log levels appropriately",
            ),
            
            # ==================== INJECTION VULNERABILITIES ====================
            "SQL_INJECTION": VulnerabilityPattern(
                id="SQL_INJECTION",
                name="SQL Injection",
                category=VulnerabilityCategory.INJECTION,
                severity=VulnerabilitySeverity.CRITICAL,
                description="SQL query constructed from unsanitized input",
                owasp_mstg="MSTG-CODE-4",
                cwe="CWE-89",
                api_patterns=["rawQuery", "execSQL"],
                string_patterns=["SELECT", "DELETE", "UPDATE"],
                remediation="Use parameterized queries or ORM",
            ),
            
            # ==================== ANDROID-SPECIFIC ====================
            "WEAK_RANDOMNESS": VulnerabilityPattern(
                id="WEAK_RANDOMNESS",
                name="Weak Random Number Generation",
                category=VulnerabilityCategory.ANDROID_SPECIFIC,
                severity=VulnerabilitySeverity.MEDIUM,
                description="Uses Math.random() instead of SecureRandom",
                owasp_mstg="MSTG-CRYPTO-6",
                cwe="CWE-338",
                string_patterns=["Math.random"],
                api_patterns=["new Random()"],
                remediation="Use SecureRandom for security-sensitive operations",
            ),
            
            "INSECURE_DESERIALIZE": VulnerabilityPattern(
                id="INSECURE_DESERIALIZE",
                name="Insecure Deserialization",
                category=VulnerabilityCategory.ANDROID_SPECIFIC,
                severity=VulnerabilitySeverity.CRITICAL,
                description="Unsafe deserialization of untrusted data",
                owasp_mstg="MSTG-ANDROID-8",
                cwe="CWE-502",
                api_patterns=["ObjectInputStream", "readSerializable", "readObject"],
                remediation="Use safe serialization or validate all deserialized objects",
            ),
        }
        
        return patterns


class VulnerabilityScannerV2:
    """Enhanced vulnerability scanner with manifest and code analysis"""
    
    def __init__(self, extracted_dir: Optional[Path] = None):
        self.patterns = VulnerabilityPatternsV2.get_all_patterns()
        self.found_vulnerabilities: List[Vulnerability] = []
        self.extracted_dir = extracted_dir
        self.manifest_content = ""
        
        # Load manifest if available
        if extracted_dir:
            self._load_manifest(extracted_dir)
    
    def _load_manifest(self, extracted_dir: Path):
        """Load AndroidManifest.xml from extracted APK"""
        manifest_path = extracted_dir / "AndroidManifest.xml"
        if manifest_path.exists():
            try:
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    self.manifest_content = f.read()
                logger.info(f"Loaded manifest ({len(self.manifest_content)} bytes)")
            except Exception as e:
                logger.warning(f"Failed to load manifest: {e}")
    
    def scan(self, decompiled_classes: List, source_code_map: Dict = None) -> List[Vulnerability]:
        """
        Comprehensive vulnerability scanning:
        1. Manifest analysis (exported components)
        2. Code pattern analysis
        3. Evidence collection with source code
        
        Args:
            decompiled_classes: List of DecompiledClass objects
            source_code_map: Dict mapping class names to source code
        
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        # 1. Analyze Manifest for exported components
        manifest_vulns = self._analyze_manifest()
        vulnerabilities.extend(manifest_vulns)
        
        # 2. Analyze decompiled code
        for cls in decompiled_classes:
            class_vulns = self._analyze_class(cls)
            vulnerabilities.extend(class_vulns)
        
        self.found_vulnerabilities = vulnerabilities
        logger.info(f"Detected {len(vulnerabilities)} vulnerabilities")
        
        return vulnerabilities
    
    def _analyze_manifest(self) -> List[Vulnerability]:
        """Analyze AndroidManifest.xml for security issues"""
        vulnerabilities = []
        
        if not self.manifest_content:
            return vulnerabilities
        
        # Check for exported components - include multiline matching
        exported_patterns = {
            "activity": ("COMP_EXPORTED_ACTIVITY", r'<activity[^>]*exported="true"[^>]*>'),
            "service": ("COMP_EXPORTED_SERVICE", r'<service[^>]*exported="true"[^>]*>'),
            "receiver": ("COMP_EXPORTED_BROADCAST", r'<receiver[^>]*exported="true"[^>]*>'),
            "provider": ("COMP_EXPORTED_CONTENT", r'<provider[^>]*exported="true"[^>]*>'),
        }
        
        for component_type, (vuln_id, pattern) in exported_patterns.items():
            # Find all exported components of this type
            matches = re.finditer(pattern, self.manifest_content, re.IGNORECASE)
            for match in matches:
                component_text = match.group(0)
                
                # Extract component name - try multiple patterns
                component_name = "Unknown"
                
                # Try android:name attribute
                name_match = re.search(r'android:name="([^"]+)"', component_text)
                if name_match:
                    component_name = name_match.group(1)
                else:
                    # If not in this element, search nearby (it might be on next line)
                    start_pos = max(0, match.start() - 200)
                    end_pos = min(len(self.manifest_content), match.end() + 200)
                    context = self.manifest_content[start_pos:end_pos]
                    name_match = re.search(r'android:name="([^"]+)"', context)
                    if name_match:
                        component_name = name_match.group(1)
                
                if vuln_id in self.patterns:
                    pattern_obj = self.patterns[vuln_id]
                    
                    vuln = Vulnerability(
                        vulnerability_id=vuln_id,
                        name=pattern_obj.name,
                        category=pattern_obj.category.value,
                        severity=pattern_obj.severity.value,
                        location={
                            "file": "AndroidManifest.xml",
                            "type": "manifest",
                            "component": component_name,
                            "component_type": component_type,
                        },
                        evidence=[component_text],
                        description=pattern_obj.description,
                        remediation=pattern_obj.remediation,
                        cwe=pattern_obj.cwe,
                        owasp_mstg=pattern_obj.owasp_mstg,
                        source_code=component_text,
                    )
                    vulnerabilities.append(vuln)
                    logger.debug(f"Found {vuln.name} in {component_name}")
        
        return vulnerabilities
    
    def _analyze_class(self, decompiled_class) -> List[Vulnerability]:
        """Analyze a decompiled class for vulnerabilities"""
        vulnerabilities = []
        
        class_name = getattr(decompiled_class, 'name', 'Unknown')
        
        # Check methods
        methods = getattr(decompiled_class, 'methods', [])
        for method in methods:
            method_name = getattr(method, 'name', 'Unknown')
            code_lines = getattr(method, 'code_lines', [])
            code_str = "\n".join(code_lines) if isinstance(code_lines, list) else str(code_lines)
            
            # Check each pattern
            for pattern_id, pattern in self.patterns.items():
                # String patterns
                for string_pattern in pattern.string_patterns:
                    if string_pattern.lower() in code_str.lower():
                        # Additional context checks to reduce FP
                        if self._is_vulnerable(pattern_id, code_str, class_name):
                            vuln = self._create_vulnerability(
                                pattern,
                                class_name,
                                method_name,
                                code_str,
                                code_lines
                            )
                            vulnerabilities.append(vuln)
                            break
                
                # API patterns
                for api_pattern in pattern.api_patterns:
                    if api_pattern in code_str:
                        if self._is_vulnerable(pattern_id, code_str, class_name):
                            vuln = self._create_vulnerability(
                                pattern,
                                class_name,
                                method_name,
                                code_str,
                                code_lines
                            )
                            vulnerabilities.append(vuln)
                            break
                
                # Regex patterns
                for regex_pattern in pattern.regex_patterns:
                    try:
                        if re.search(regex_pattern, code_str, re.IGNORECASE):
                            if self._is_vulnerable(pattern_id, code_str, class_name):
                                vuln = self._create_vulnerability(
                                    pattern,
                                    class_name,
                                    method_name,
                                    code_str,
                                    code_lines
                                )
                                vulnerabilities.append(vuln)
                                break
                    except re.error:
                        pass
        
        return vulnerabilities
    
    def _is_vulnerable(self, pattern_id: str, code_str: str, class_name: str = "") -> bool:
        """Additional context checks to reduce false positives"""
        
        # Filter out library code (okhttp, okio, androidx, support, google, etc)
        library_packages = [
            "okhttp", "okio", "androidx", "android.support", "com.google",
            "com.android", "junit", "org.junit", "org.mockito", "org.hamcrest",
            "org.apache", "com.fasterxml", "org.json", "org.slf4j"
        ]
        
        for lib in library_packages:
            if lib in class_name.lower():
                return False  # Skip library code
        
        # Pattern-specific checks
        if "EXPORTED" in pattern_id:
            return True  # Manifest-based, not code
        
        if "HARDCODED" in pattern_id:
            # STRICT: Only detect if it looks like actual assignment with string literals
            # Skip method signatures, comments, and Smali metadata
            if code_str.strip().startswith(("//", ".method", ".field", ".locals", ".line", ".annotation")):
                return False
            
            # Check for actual string assignment patterns (Java-like)
            # Must have = or : followed by literal string
            if '="' in code_str or "='" in code_str or ': "' in code_str:
                return True
            
            # Regex patterns for actual hardcoding
            import re
            patterns = [
                r'(password|passwd|pwd|secret|api[_-]?key|token)\s*[=:]\s*["\']',
                r'(private|public|protected)\s+(static\s+)?(final\s+)?String\s+\w*(?:password|secret|key|token)',
            ]
            for regex in patterns:
                if re.search(regex, code_str, re.IGNORECASE):
                    return True
            
            return False
        
        if "WEAK_CRYPTO" in pattern_id:
            # Check if used in actual cryptographic operation
            # Must be in getInstance() call or actual usage
            return "getInstance" in code_str or "Cipher" in code_str or "MessageDigest" in code_str or "getAlgorithm" in code_str
        
        if "SQL_INJECTION" in pattern_id:
            # Check for string concatenation with SQL
            return "+" in code_str and ("SELECT" in code_str or "INSERT" in code_str or "UPDATE" in code_str)
        
        return True
    
    def _create_vulnerability(self, pattern: VulnerabilityPattern, 
                             class_name: str, method_name: str,
                             code_str: str, code_lines: List) -> Vulnerability:
        """Create Vulnerability object with evidence"""
        
        # Extract snippet around pattern
        lines = code_str.split("\n")
        evidence = lines[:5] if len(lines) <= 5 else lines[:3] + ["..."] + lines[-2:]
        
        # Find line numbers
        line_nums = []
        for i, line in enumerate(lines):
            for pattern_str in pattern.string_patterns + pattern.api_patterns:
                if pattern_str.lower() in line.lower():
                    line_nums.append(i + 1)
                    break
        
        vuln = Vulnerability(
            vulnerability_id=pattern.id,
            name=pattern.name,
            category=pattern.category.value,
            severity=pattern.severity.value,
            location={
                "file": f"{class_name}.java",
                "class": class_name,
                "method": method_name,
            },
            evidence=evidence,
            description=pattern.description,
            remediation=pattern.remediation,
            cwe=pattern.cwe,
            owasp_mstg=pattern.owasp_mstg,
            source_code=code_str[:500],  # First 500 chars
            line_numbers=line_nums,
        )
        
        return vuln
    
    def get_summary(self) -> Dict:
        """Get vulnerability summary"""
        
        severity_counts = {}
        category_counts = {}
        
        for vuln in self.found_vulnerabilities:
            sev = vuln.severity
            severity_counts[sev] = severity_counts.get(sev, 0) + 1
            
            cat = vuln.category
            category_counts[cat] = category_counts.get(cat, 0) + 1
        
        return {
            "total_vulnerabilities": len(self.found_vulnerabilities),
            "by_severity": severity_counts,
            "by_category": category_counts,
            "critical_count": severity_counts.get("Critical", 0),
            "high_count": severity_counts.get("High", 0),
        }
