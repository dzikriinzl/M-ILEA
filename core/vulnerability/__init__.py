"""
Vulnerability Analysis Module

Provides comprehensive vulnerability detection across:
- Network security (unencrypted transmission, insecure protocols)
- Cryptography (weak algorithms, hardcoded keys)
- Data storage (unencrypted preferences, databases)
- Component security (exported components, permissions)
- Android-specific (unsafe APIs, SQL injection, etc.)

Reference: MobSF, DroidLLMHunter, OWASP Top 10 Mobile
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Tuple
from enum import Enum
import logging
import json

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Info"


class VulnerabilityCategory(Enum):
    """Vulnerability categories"""
    NETWORK_SECURITY = "Network Security"
    CRYPTOGRAPHY = "Cryptography"
    DATA_STORAGE = "Data Storage"
    COMPONENT_SECURITY = "Component Security"
    CODE_QUALITY = "Code Quality"
    REVERSE_ENGINEERING = "Reverse Engineering"
    PERMISSIONS = "Permissions"
    AUTHENTICATION = "Authentication"
    INJECTION = "Injection"
    ANDROID_SPECIFIC = "Android-Specific"


@dataclass
class VulnerabilityPattern:
    """Pattern definition for vulnerability detection"""
    id: str                              # Unique identifier
    name: str                            # Vulnerability name
    category: VulnerabilityCategory      # Category
    severity: VulnerabilitySeverity      # Severity level
    description: str                     # Description
    api_patterns: List[str] = field(default_factory=list)  # APIs to detect
    string_patterns: List[str] = field(default_factory=list)  # Strings to find
    method_patterns: List[str] = field(default_factory=list)  # Methods to check
    remediation: str = ""                # How to fix
    references: List[str] = field(default_factory=list)  # OWASP/CVE refs


@dataclass
class Vulnerability:
    """Detected vulnerability in app"""
    vulnerability_id: str
    name: str
    category: str
    severity: str
    location: Dict                       # {file, class, method, line}
    evidence: List[str]                  # Code evidence
    description: str = ""
    remediation: str = ""
    cwe: Optional[str] = None            # CWE identifier
    owasp: Optional[str] = None          # OWASP category
    
    def to_dict(self):
        return {
            "id": self.vulnerability_id,
            "name": self.name,
            "category": self.category,
            "severity": self.severity,
            "location": self.location,
            "evidence": self.evidence,
            "description": self.description,
            "remediation": self.remediation,
            "cwe": self.cwe,
            "owasp": self.owasp,
        }


class VulnerabilityPatterns:
    """Registry of vulnerability patterns"""
    
    @staticmethod
    def get_all_patterns() -> Dict[str, VulnerabilityPattern]:
        """Return all vulnerability patterns"""
        
        patterns = {
            # ==================== NETWORK SECURITY ====================
            "NET_UNENCRYPTED_HTTP": VulnerabilityPattern(
                id="NET_UNENCRYPTED_HTTP",
                name="Unencrypted HTTP Communication",
                category=VulnerabilityCategory.NETWORK_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="App uses unencrypted HTTP for data transmission",
                api_patterns=["HttpURLConnection", "URL.openConnection", "http://"],
                string_patterns=["http://", "cleartext"],
                remediation="Use HTTPS (TLS/SSL) for all network communication",
                references=["OWASP-M2", "CWE-295"]
            ),
            
            "NET_NO_CERT_PINNING": VulnerabilityPattern(
                id="NET_NO_CERT_PINNING",
                name="Missing Certificate Pinning",
                category=VulnerabilityCategory.NETWORK_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="No certificate pinning implemented for sensitive APIs",
                api_patterns=["HttpsURLConnection", "SSLContext", "TrustManager"],
                remediation="Implement certificate/public key pinning",
                references=["OWASP-M3"]
            ),
            
            # ==================== CRYPTOGRAPHY ====================
            "CRYPTO_WEAK_ALGORITHM": VulnerabilityPattern(
                id="CRYPTO_WEAK_ALGORITHM",
                name="Weak Cryptographic Algorithm",
                category=VulnerabilityCategory.CRYPTOGRAPHY,
                severity=VulnerabilitySeverity.HIGH,
                description="Uses weak cryptographic algorithms (MD5, SHA1, RC4, DES)",
                api_patterns=["MD5", "SHA1", "RC4", "DES", "Cipher.getInstance"],
                string_patterns=["MD5", "SHA1", "RC4", "DES", "ECB"],
                remediation="Use strong algorithms: AES-256, SHA-256, PBKDF2",
                references=["OWASP-M5", "CWE-327"]
            ),
            
            "CRYPTO_HARDCODED_KEY": VulnerabilityPattern(
                id="CRYPTO_HARDCODED_KEY",
                name="Hardcoded Cryptographic Key",
                category=VulnerabilityCategory.CRYPTOGRAPHY,
                severity=VulnerabilitySeverity.CRITICAL,
                description="Cryptographic keys hardcoded in source code",
                string_patterns=["private static final byte[]", "Key =", "SECRET_KEY"],
                remediation="Store keys in secure key management system",
                references=["OWASP-M2", "CWE-321"]
            ),
            
            # ==================== DATA STORAGE ====================
            "STORAGE_PLAINTEXT": VulnerabilityPattern(
                id="STORAGE_PLAINTEXT",
                name="Plaintext Data Storage",
                category=VulnerabilityCategory.DATA_STORAGE,
                severity=VulnerabilitySeverity.HIGH,
                description="Sensitive data stored in plaintext",
                api_patterns=["SharedPreferences", "getSharedPreferences", "edit()"],
                string_patterns=["password", "token", "secret", "credential"],
                remediation="Encrypt sensitive data before storage",
                references=["OWASP-M2"]
            ),
            
            "STORAGE_EXTERNAL": VulnerabilityPattern(
                id="STORAGE_EXTERNAL",
                name="Sensitive Data on External Storage",
                category=VulnerabilityCategory.DATA_STORAGE,
                severity=VulnerabilitySeverity.MEDIUM,
                description="Sensitive data stored on world-readable external storage",
                api_patterns=["getExternalFilesDir", "getExternalCacheDir", "Environment.getExternalStorageDirectory"],
                string_patterns=["external", "sdcard", "/mnt/sdcard"],
                remediation="Use internal storage with proper permissions",
                references=["OWASP-M2"]
            ),
            
            # ==================== COMPONENT SECURITY ====================
            "COMPONENT_EXPORTED_ACTIVITY": VulnerabilityPattern(
                id="COMP_EXPORTED_ACTIVITY",
                name="Exported Activity",
                category=VulnerabilityCategory.COMPONENT_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="Activity is exported without proper protection",
                string_patterns=["<activity", "exported=\"true\""],
                remediation="Set exported=false or add proper permission checks",
                references=["OWASP-M1"]
            ),
            
            "COMPONENT_EXPORTED_SERVICE": VulnerabilityPattern(
                id="COMP_EXPORTED_SERVICE",
                name="Exported Service",
                category=VulnerabilityCategory.COMPONENT_SECURITY,
                severity=VulnerabilitySeverity.HIGH,
                description="Service is exported without proper protection",
                string_patterns=["<service", "exported=\"true\""],
                remediation="Set exported=false or add permission checks",
                references=["OWASP-M1"]
            ),
            
            # ==================== CODE QUALITY ====================
            "CODE_DEBUG_LOGS": VulnerabilityPattern(
                id="CODE_DEBUG_LOGS",
                name="Debug Logging Enabled",
                category=VulnerabilityCategory.CODE_QUALITY,
                severity=VulnerabilitySeverity.MEDIUM,
                description="App logs sensitive information to system logs",
                api_patterns=["Log.d", "Log.v", "System.out.println"],
                string_patterns=["DEBUG", "VERBOSE", "password", "token"],
                remediation="Remove debug logs or only log in debug builds",
                references=["OWASP-M4"]
            ),
            
            "CODE_HARDCODED_SECRET": VulnerabilityPattern(
                id="CODE_HARDCODED_SECRET",
                name="Hardcoded Secrets",
                category=VulnerabilityCategory.CODE_QUALITY,
                severity=VulnerabilitySeverity.CRITICAL,
                description="Secrets (API keys, passwords) hardcoded in code",
                string_patterns=["password", "api_key", "secret", "token", "API-KEY"],
                remediation="Use external configuration or secure storage",
                references=["OWASP-M2"]
            ),
            
            # ==================== INJECTION ====================
            "INJECTION_SQL": VulnerabilityPattern(
                id="INJECTION_SQL",
                name="SQL Injection Vulnerability",
                category=VulnerabilityCategory.INJECTION,
                severity=VulnerabilitySeverity.CRITICAL,
                description="SQL injection vulnerability in database queries",
                api_patterns=["rawQuery", "execSQL"],
                string_patterns=["SELECT", "INSERT", "UPDATE", "DELETE", "+"],
                method_patterns=["String concatenation with user input"],
                remediation="Use parameterized queries (PreparedStatement)",
                references=["OWASP-M7", "CWE-89"]
            ),
            
            "INJECTION_COMMAND": VulnerabilityPattern(
                id="INJECTION_COMMAND",
                name="Command Injection",
                category=VulnerabilityCategory.INJECTION,
                severity=VulnerabilitySeverity.CRITICAL,
                description="Command execution vulnerability",
                api_patterns=["Runtime.exec", "ProcessBuilder"],
                remediation="Avoid executing shell commands, use APIs instead",
                references=["OWASP-M7", "CWE-78"]
            ),
            
            # ==================== ANDROID-SPECIFIC ====================
            "ANDROID_INSECURE_DESERIALIZATION": VulnerabilityPattern(
                id="ANDROID_INSECURE_DESER",
                name="Insecure Deserialization",
                category=VulnerabilityCategory.ANDROID_SPECIFIC,
                severity=VulnerabilitySeverity.CRITICAL,
                description="Unsafe deserialization of untrusted data",
                api_patterns=["ObjectInputStream", "Parcel.readSerializable"],
                remediation="Validate and sanitize serialized data",
                references=["OWASP-M8"]
            ),
            
            "ANDROID_WEAK_RANDOMNESS": VulnerabilityPattern(
                id="ANDROID_WEAK_RANDOM",
                name="Weak Randomness",
                category=VulnerabilityCategory.ANDROID_SPECIFIC,
                severity=VulnerabilitySeverity.MEDIUM,
                description="Uses weak random number generator",
                api_patterns=["Random", "Math.random"],
                remediation="Use SecureRandom for cryptographic purposes",
                references=["CWE-338"]
            ),
            
            "ANDROID_WORLD_READABLE": VulnerabilityPattern(
                id="ANDROID_WORLD_READABLE",
                name="World-Readable Files",
                category=VulnerabilityCategory.ANDROID_SPECIFIC,
                severity=VulnerabilitySeverity.HIGH,
                description="Files created with world-readable permissions",
                api_patterns=["MODE_WORLD_READABLE", "MODE_WORLD_WRITABLE"],
                remediation="Use MODE_PRIVATE for sensitive files",
                references=["OWASP-M2"]
            ),
        }
        
        return patterns


class VulnerabilityScanner:
    """
    Scan app for vulnerabilities.
    
    Integrates with analyzer to detect patterns in decompiled code.
    """
    
    def __init__(self):
        self.patterns = VulnerabilityPatterns.get_all_patterns()
        self.found_vulnerabilities: List[Vulnerability] = []
    
    def scan_findings(self, findings: List, manifest_content: str = "") -> List[Vulnerability]:
        """
        Scan findings for vulnerabilities.
        
        Args:
            findings: List of findings from analyzer
            manifest_content: AndroidManifest.xml content for component analysis
        
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        # Scan findings for patterns
        for finding in findings:
            vuln_list = self._analyze_finding(finding)
            vulnerabilities.extend(vuln_list)
        
        # Scan manifest for component vulnerabilities
        if manifest_content:
            manifest_vulns = self._analyze_manifest(manifest_content)
            vulnerabilities.extend(manifest_vulns)
        
        self.found_vulnerabilities = vulnerabilities
        return vulnerabilities
    
    def _analyze_finding(self, finding) -> List[Vulnerability]:
        """Analyze single finding for vulnerabilities"""
        vulnerabilities = []
        
        evidence = getattr(finding, 'evidence_snippet', [])
        evidence_str = ''.join(evidence)
        
        location = getattr(finding, 'location', {})
        if not isinstance(location, dict):
            location = asdict(location)
        
        # Check each pattern
        for pattern_id, pattern in self.patterns.items():
            is_match = False
            
            # Check API patterns
            for api in pattern.api_patterns:
                if api in evidence_str:
                    is_match = True
                    break
            
            # Check string patterns
            if not is_match:
                for string_pattern in pattern.string_patterns:
                    if string_pattern.lower() in evidence_str.lower():
                        is_match = True
                        break
            
            if is_match:
                vuln = Vulnerability(
                    vulnerability_id=pattern.id,
                    name=pattern.name,
                    category=pattern.category.value,
                    severity=pattern.severity.value,
                    location=location,
                    evidence=evidence,
                    description=pattern.description,
                    remediation=pattern.remediation,
                    owasp=pattern.references[0] if pattern.references else None
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _analyze_manifest(self, manifest_content: str) -> List[Vulnerability]:
        """Analyze AndroidManifest.xml for vulnerabilities"""
        vulnerabilities = []
        
        # Check for exported components
        if 'android:exported="true"' in manifest_content or 'exported="true"' in manifest_content:
            
            # Check activities
            if '<activity' in manifest_content and 'exported="true"' in manifest_content:
                vuln = Vulnerability(
                    vulnerability_id="COMP_EXPORTED_ACTIVITY",
                    name="Exported Activity",
                    category="Component Security",
                    severity="High",
                    location={"file": "AndroidManifest.xml", "type": "manifest"},
                    evidence=["<activity android:exported=\"true\" />"],
                    remediation="Set exported=false or add permission checks"
                )
                vulnerabilities.append(vuln)
            
            # Check services
            if '<service' in manifest_content and 'exported="true"' in manifest_content:
                vuln = Vulnerability(
                    vulnerability_id="COMP_EXPORTED_SERVICE",
                    name="Exported Service",
                    category="Component Security",
                    severity="High",
                    location={"file": "AndroidManifest.xml", "type": "manifest"},
                    evidence=["<service android:exported=\"true\" />"],
                    remediation="Set exported=false or add permission checks"
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def get_vulnerability_summary(self) -> Dict:
        """Get summary of found vulnerabilities"""
        
        severity_counts = {}
        category_counts = {}
        
        for vuln in self.found_vulnerabilities:
            # Count by severity
            sev = vuln.severity
            severity_counts[sev] = severity_counts.get(sev, 0) + 1
            
            # Count by category
            cat = vuln.category
            category_counts[cat] = category_counts.get(cat, 0) + 1
        
        return {
            "total_vulnerabilities": len(self.found_vulnerabilities),
            "by_severity": severity_counts,
            "by_category": category_counts,
            "critical_count": severity_counts.get("Critical", 0),
            "high_count": severity_counts.get("High", 0),
        }
    
    def correlate_with_protections(self, vulnerabilities: List[Vulnerability], 
                                  protection_findings: List) -> Dict:
        """
        Correlate detected vulnerabilities with protection mechanisms.
        
        Answers: Which protections are addressing which vulnerabilities?
        """
        
        correlation = {}
        
        for vuln in vulnerabilities:
            # Find protections that might address this vuln
            addressing_protections = []
            
            for finding in protection_findings:
                ptype = getattr(finding, 'protection_type', '')
                
                # Simple heuristic: match based on vulnerability type
                if "Root Detection" in ptype and "privilege" in vuln.name.lower():
                    addressing_protections.append(ptype)
                elif "Debugger" in ptype and "reverse" in vuln.category.lower():
                    addressing_protections.append(ptype)
                elif "Tampering" in ptype and "integrity" in vuln.category.lower():
                    addressing_protections.append(ptype)
            
            correlation[vuln.vulnerability_id] = {
                "vulnerability": vuln.name,
                "addressing_protections": addressing_protections,
                "has_protection": len(addressing_protections) > 0
            }
        
        return correlation


from dataclasses import asdict
